// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.1
// source: processingdatabase.proto

package ProcessingDatabase

import (
	FileExchange "Dressy/FileExchange"
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ProcessingDatabaseRecords_InsertRecords_FullMethodName         = "/Dressy.ProcessingDatabase.ProcessingDatabaseRecords/InsertRecords"
	ProcessingDatabaseRecords_ImportCsv_FullMethodName             = "/Dressy.ProcessingDatabase.ProcessingDatabaseRecords/ImportCsv"
	ProcessingDatabaseRecords_GetRecordsByStatus_FullMethodName    = "/Dressy.ProcessingDatabase.ProcessingDatabaseRecords/GetRecordsByStatus"
	ProcessingDatabaseRecords_GetEmbeddingsByStatus_FullMethodName = "/Dressy.ProcessingDatabase.ProcessingDatabaseRecords/GetEmbeddingsByStatus"
	ProcessingDatabaseRecords_GetRecordById_FullMethodName         = "/Dressy.ProcessingDatabase.ProcessingDatabaseRecords/GetRecordById"
	ProcessingDatabaseRecords_UpdateRecordById_FullMethodName      = "/Dressy.ProcessingDatabase.ProcessingDatabaseRecords/UpdateRecordById"
	ProcessingDatabaseRecords_Authentication_FullMethodName        = "/Dressy.ProcessingDatabase.ProcessingDatabaseRecords/Authentication"
	ProcessingDatabaseRecords_ClearTable_FullMethodName            = "/Dressy.ProcessingDatabase.ProcessingDatabaseRecords/ClearTable"
)

// ProcessingDatabaseRecordsClient is the client API for ProcessingDatabaseRecords service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
//	'Records' table
type ProcessingDatabaseRecordsClient interface {
	// Inserts data into a table, one at a time, in a batch, or from a csv file
	InsertRecords(ctx context.Context, in *InsertRecordsRequest, opts ...grpc.CallOption) (*InsertRecordsResponse, error)
	ImportCsv(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileExchange.FileData, FileExchange.UploadStatus], error)
	// Getting data by status, allowed only for preprocessor and processor
	// For preprocessor allowed status is only NEW, for processor allowed NEW and PREPROCESSED (depends on processor posibilities) status
	GetRecordsByStatus(ctx context.Context, in *GetRecordsByStatusRequest, opts ...grpc.CallOption) (*GetRecordsByStatusResponse, error)
	GetEmbeddingsByStatus(ctx context.Context, in *GetEmbeddingsByStatusRequest, opts ...grpc.CallOption) (*GetEmbeddingsByStatusResponse, error)
	// Getting data by Id, use for getting data after search
	GetRecordById(ctx context.Context, in *GetRecordByIdRequest, opts ...grpc.CallOption) (*GetRecordByIdResponse, error)
	// Updating data after preprocessing or processing, status will be updated automatically
	UpdateRecordById(ctx context.Context, in *UpdateRecordByIdRequest, opts ...grpc.CallOption) (*UpdateRecordByIdResponse, error)
	// !!!!!FOR TEST ENVIRONMENT ONLY!!!!!! Clearing table
	Authentication(ctx context.Context, in *AuthenticationRequest, opts ...grpc.CallOption) (*AuthenticationResponse, error)
	ClearTable(ctx context.Context, in *ClearTableRequest, opts ...grpc.CallOption) (*ClearTableResponse, error)
}

type processingDatabaseRecordsClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessingDatabaseRecordsClient(cc grpc.ClientConnInterface) ProcessingDatabaseRecordsClient {
	return &processingDatabaseRecordsClient{cc}
}

func (c *processingDatabaseRecordsClient) InsertRecords(ctx context.Context, in *InsertRecordsRequest, opts ...grpc.CallOption) (*InsertRecordsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertRecordsResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseRecords_InsertRecords_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processingDatabaseRecordsClient) ImportCsv(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileExchange.FileData, FileExchange.UploadStatus], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ProcessingDatabaseRecords_ServiceDesc.Streams[0], ProcessingDatabaseRecords_ImportCsv_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FileExchange.FileData, FileExchange.UploadStatus]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ProcessingDatabaseRecords_ImportCsvClient = grpc.ClientStreamingClient[FileExchange.FileData, FileExchange.UploadStatus]

func (c *processingDatabaseRecordsClient) GetRecordsByStatus(ctx context.Context, in *GetRecordsByStatusRequest, opts ...grpc.CallOption) (*GetRecordsByStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRecordsByStatusResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseRecords_GetRecordsByStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processingDatabaseRecordsClient) GetEmbeddingsByStatus(ctx context.Context, in *GetEmbeddingsByStatusRequest, opts ...grpc.CallOption) (*GetEmbeddingsByStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEmbeddingsByStatusResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseRecords_GetEmbeddingsByStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processingDatabaseRecordsClient) GetRecordById(ctx context.Context, in *GetRecordByIdRequest, opts ...grpc.CallOption) (*GetRecordByIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRecordByIdResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseRecords_GetRecordById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processingDatabaseRecordsClient) UpdateRecordById(ctx context.Context, in *UpdateRecordByIdRequest, opts ...grpc.CallOption) (*UpdateRecordByIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRecordByIdResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseRecords_UpdateRecordById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processingDatabaseRecordsClient) Authentication(ctx context.Context, in *AuthenticationRequest, opts ...grpc.CallOption) (*AuthenticationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthenticationResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseRecords_Authentication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processingDatabaseRecordsClient) ClearTable(ctx context.Context, in *ClearTableRequest, opts ...grpc.CallOption) (*ClearTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearTableResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseRecords_ClearTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessingDatabaseRecordsServer is the server API for ProcessingDatabaseRecords service.
// All implementations must embed UnimplementedProcessingDatabaseRecordsServer
// for forward compatibility.
//
//	'Records' table
type ProcessingDatabaseRecordsServer interface {
	// Inserts data into a table, one at a time, in a batch, or from a csv file
	InsertRecords(context.Context, *InsertRecordsRequest) (*InsertRecordsResponse, error)
	ImportCsv(grpc.ClientStreamingServer[FileExchange.FileData, FileExchange.UploadStatus]) error
	// Getting data by status, allowed only for preprocessor and processor
	// For preprocessor allowed status is only NEW, for processor allowed NEW and PREPROCESSED (depends on processor posibilities) status
	GetRecordsByStatus(context.Context, *GetRecordsByStatusRequest) (*GetRecordsByStatusResponse, error)
	GetEmbeddingsByStatus(context.Context, *GetEmbeddingsByStatusRequest) (*GetEmbeddingsByStatusResponse, error)
	// Getting data by Id, use for getting data after search
	GetRecordById(context.Context, *GetRecordByIdRequest) (*GetRecordByIdResponse, error)
	// Updating data after preprocessing or processing, status will be updated automatically
	UpdateRecordById(context.Context, *UpdateRecordByIdRequest) (*UpdateRecordByIdResponse, error)
	// !!!!!FOR TEST ENVIRONMENT ONLY!!!!!! Clearing table
	Authentication(context.Context, *AuthenticationRequest) (*AuthenticationResponse, error)
	ClearTable(context.Context, *ClearTableRequest) (*ClearTableResponse, error)
	mustEmbedUnimplementedProcessingDatabaseRecordsServer()
}

// UnimplementedProcessingDatabaseRecordsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProcessingDatabaseRecordsServer struct{}

func (UnimplementedProcessingDatabaseRecordsServer) InsertRecords(context.Context, *InsertRecordsRequest) (*InsertRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertRecords not implemented")
}
func (UnimplementedProcessingDatabaseRecordsServer) ImportCsv(grpc.ClientStreamingServer[FileExchange.FileData, FileExchange.UploadStatus]) error {
	return status.Errorf(codes.Unimplemented, "method ImportCsv not implemented")
}
func (UnimplementedProcessingDatabaseRecordsServer) GetRecordsByStatus(context.Context, *GetRecordsByStatusRequest) (*GetRecordsByStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRecordsByStatus not implemented")
}
func (UnimplementedProcessingDatabaseRecordsServer) GetEmbeddingsByStatus(context.Context, *GetEmbeddingsByStatusRequest) (*GetEmbeddingsByStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEmbeddingsByStatus not implemented")
}
func (UnimplementedProcessingDatabaseRecordsServer) GetRecordById(context.Context, *GetRecordByIdRequest) (*GetRecordByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRecordById not implemented")
}
func (UnimplementedProcessingDatabaseRecordsServer) UpdateRecordById(context.Context, *UpdateRecordByIdRequest) (*UpdateRecordByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRecordById not implemented")
}
func (UnimplementedProcessingDatabaseRecordsServer) Authentication(context.Context, *AuthenticationRequest) (*AuthenticationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authentication not implemented")
}
func (UnimplementedProcessingDatabaseRecordsServer) ClearTable(context.Context, *ClearTableRequest) (*ClearTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearTable not implemented")
}
func (UnimplementedProcessingDatabaseRecordsServer) mustEmbedUnimplementedProcessingDatabaseRecordsServer() {
}
func (UnimplementedProcessingDatabaseRecordsServer) testEmbeddedByValue() {}

// UnsafeProcessingDatabaseRecordsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessingDatabaseRecordsServer will
// result in compilation errors.
type UnsafeProcessingDatabaseRecordsServer interface {
	mustEmbedUnimplementedProcessingDatabaseRecordsServer()
}

func RegisterProcessingDatabaseRecordsServer(s grpc.ServiceRegistrar, srv ProcessingDatabaseRecordsServer) {
	// If the following call pancis, it indicates UnimplementedProcessingDatabaseRecordsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProcessingDatabaseRecords_ServiceDesc, srv)
}

func _ProcessingDatabaseRecords_InsertRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseRecordsServer).InsertRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseRecords_InsertRecords_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseRecordsServer).InsertRecords(ctx, req.(*InsertRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessingDatabaseRecords_ImportCsv_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ProcessingDatabaseRecordsServer).ImportCsv(&grpc.GenericServerStream[FileExchange.FileData, FileExchange.UploadStatus]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ProcessingDatabaseRecords_ImportCsvServer = grpc.ClientStreamingServer[FileExchange.FileData, FileExchange.UploadStatus]

func _ProcessingDatabaseRecords_GetRecordsByStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRecordsByStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseRecordsServer).GetRecordsByStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseRecords_GetRecordsByStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseRecordsServer).GetRecordsByStatus(ctx, req.(*GetRecordsByStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessingDatabaseRecords_GetEmbeddingsByStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEmbeddingsByStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseRecordsServer).GetEmbeddingsByStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseRecords_GetEmbeddingsByStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseRecordsServer).GetEmbeddingsByStatus(ctx, req.(*GetEmbeddingsByStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessingDatabaseRecords_GetRecordById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRecordByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseRecordsServer).GetRecordById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseRecords_GetRecordById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseRecordsServer).GetRecordById(ctx, req.(*GetRecordByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessingDatabaseRecords_UpdateRecordById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRecordByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseRecordsServer).UpdateRecordById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseRecords_UpdateRecordById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseRecordsServer).UpdateRecordById(ctx, req.(*UpdateRecordByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessingDatabaseRecords_Authentication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseRecordsServer).Authentication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseRecords_Authentication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseRecordsServer).Authentication(ctx, req.(*AuthenticationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessingDatabaseRecords_ClearTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseRecordsServer).ClearTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseRecords_ClearTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseRecordsServer).ClearTable(ctx, req.(*ClearTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProcessingDatabaseRecords_ServiceDesc is the grpc.ServiceDesc for ProcessingDatabaseRecords service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProcessingDatabaseRecords_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Dressy.ProcessingDatabase.ProcessingDatabaseRecords",
	HandlerType: (*ProcessingDatabaseRecordsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InsertRecords",
			Handler:    _ProcessingDatabaseRecords_InsertRecords_Handler,
		},
		{
			MethodName: "GetRecordsByStatus",
			Handler:    _ProcessingDatabaseRecords_GetRecordsByStatus_Handler,
		},
		{
			MethodName: "GetEmbeddingsByStatus",
			Handler:    _ProcessingDatabaseRecords_GetEmbeddingsByStatus_Handler,
		},
		{
			MethodName: "GetRecordById",
			Handler:    _ProcessingDatabaseRecords_GetRecordById_Handler,
		},
		{
			MethodName: "UpdateRecordById",
			Handler:    _ProcessingDatabaseRecords_UpdateRecordById_Handler,
		},
		{
			MethodName: "Authentication",
			Handler:    _ProcessingDatabaseRecords_Authentication_Handler,
		},
		{
			MethodName: "ClearTable",
			Handler:    _ProcessingDatabaseRecords_ClearTable_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ImportCsv",
			Handler:       _ProcessingDatabaseRecords_ImportCsv_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "processingdatabase.proto",
}

const (
	ProcessingDatabaseUsers_GetUserEmbeddingByKey_FullMethodName = "/Dressy.ProcessingDatabase.ProcessingDatabaseUsers/GetUserEmbeddingByKey"
	ProcessingDatabaseUsers_IsRecordViewedByUser_FullMethodName  = "/Dressy.ProcessingDatabase.ProcessingDatabaseUsers/IsRecordViewedByUser"
	ProcessingDatabaseUsers_AddViewedRecordToUser_FullMethodName = "/Dressy.ProcessingDatabase.ProcessingDatabaseUsers/AddViewedRecordToUser"
	ProcessingDatabaseUsers_DeleteUserById_FullMethodName        = "/Dressy.ProcessingDatabase.ProcessingDatabaseUsers/DeleteUserById"
)

// ProcessingDatabaseUsersClient is the client API for ProcessingDatabaseUsers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProcessingDatabaseUsersClient interface {
	// Returns user embedding by Key, if requested key is absent then this is a new user, so his Key will be added and the embedding will be generated
	GetUserEmbeddingByKey(ctx context.Context, in *GetUserEmbeddingByKeyRequest, opts ...grpc.CallOption) (*GetUserEmbeddingByKeyResponse, error)
	// Checking whether the user has seen the record or not
	// ! Returns "true" ONLY if requested user_id and record_id_list is present, and requested record_id is present in record_id_list !
	IsRecordViewedByUser(ctx context.Context, in *IsRecordViewedByUserRequest, opts ...grpc.CallOption) (*IsRecordViewedByUserResponse, error)
	// Adds user viewed record to the table, should be executed on the stage of user reaction processing
	AddViewedRecordToUser(ctx context.Context, in *AddViewedRecordToUserRequest, opts ...grpc.CallOption) (*AddViewedRecordToUserResponse, error)
	// Deleting user data, should be executed when we got a message from backend about user's decision to delete his account
	DeleteUserById(ctx context.Context, in *DeleteUserByIdRequest, opts ...grpc.CallOption) (*DeleteUserByIdResponse, error)
}

type processingDatabaseUsersClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessingDatabaseUsersClient(cc grpc.ClientConnInterface) ProcessingDatabaseUsersClient {
	return &processingDatabaseUsersClient{cc}
}

func (c *processingDatabaseUsersClient) GetUserEmbeddingByKey(ctx context.Context, in *GetUserEmbeddingByKeyRequest, opts ...grpc.CallOption) (*GetUserEmbeddingByKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserEmbeddingByKeyResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseUsers_GetUserEmbeddingByKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processingDatabaseUsersClient) IsRecordViewedByUser(ctx context.Context, in *IsRecordViewedByUserRequest, opts ...grpc.CallOption) (*IsRecordViewedByUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsRecordViewedByUserResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseUsers_IsRecordViewedByUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processingDatabaseUsersClient) AddViewedRecordToUser(ctx context.Context, in *AddViewedRecordToUserRequest, opts ...grpc.CallOption) (*AddViewedRecordToUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddViewedRecordToUserResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseUsers_AddViewedRecordToUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processingDatabaseUsersClient) DeleteUserById(ctx context.Context, in *DeleteUserByIdRequest, opts ...grpc.CallOption) (*DeleteUserByIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserByIdResponse)
	err := c.cc.Invoke(ctx, ProcessingDatabaseUsers_DeleteUserById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessingDatabaseUsersServer is the server API for ProcessingDatabaseUsers service.
// All implementations must embed UnimplementedProcessingDatabaseUsersServer
// for forward compatibility.
type ProcessingDatabaseUsersServer interface {
	// Returns user embedding by Key, if requested key is absent then this is a new user, so his Key will be added and the embedding will be generated
	GetUserEmbeddingByKey(context.Context, *GetUserEmbeddingByKeyRequest) (*GetUserEmbeddingByKeyResponse, error)
	// Checking whether the user has seen the record or not
	// ! Returns "true" ONLY if requested user_id and record_id_list is present, and requested record_id is present in record_id_list !
	IsRecordViewedByUser(context.Context, *IsRecordViewedByUserRequest) (*IsRecordViewedByUserResponse, error)
	// Adds user viewed record to the table, should be executed on the stage of user reaction processing
	AddViewedRecordToUser(context.Context, *AddViewedRecordToUserRequest) (*AddViewedRecordToUserResponse, error)
	// Deleting user data, should be executed when we got a message from backend about user's decision to delete his account
	DeleteUserById(context.Context, *DeleteUserByIdRequest) (*DeleteUserByIdResponse, error)
	mustEmbedUnimplementedProcessingDatabaseUsersServer()
}

// UnimplementedProcessingDatabaseUsersServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProcessingDatabaseUsersServer struct{}

func (UnimplementedProcessingDatabaseUsersServer) GetUserEmbeddingByKey(context.Context, *GetUserEmbeddingByKeyRequest) (*GetUserEmbeddingByKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserEmbeddingByKey not implemented")
}
func (UnimplementedProcessingDatabaseUsersServer) IsRecordViewedByUser(context.Context, *IsRecordViewedByUserRequest) (*IsRecordViewedByUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsRecordViewedByUser not implemented")
}
func (UnimplementedProcessingDatabaseUsersServer) AddViewedRecordToUser(context.Context, *AddViewedRecordToUserRequest) (*AddViewedRecordToUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddViewedRecordToUser not implemented")
}
func (UnimplementedProcessingDatabaseUsersServer) DeleteUserById(context.Context, *DeleteUserByIdRequest) (*DeleteUserByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserById not implemented")
}
func (UnimplementedProcessingDatabaseUsersServer) mustEmbedUnimplementedProcessingDatabaseUsersServer() {
}
func (UnimplementedProcessingDatabaseUsersServer) testEmbeddedByValue() {}

// UnsafeProcessingDatabaseUsersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessingDatabaseUsersServer will
// result in compilation errors.
type UnsafeProcessingDatabaseUsersServer interface {
	mustEmbedUnimplementedProcessingDatabaseUsersServer()
}

func RegisterProcessingDatabaseUsersServer(s grpc.ServiceRegistrar, srv ProcessingDatabaseUsersServer) {
	// If the following call pancis, it indicates UnimplementedProcessingDatabaseUsersServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProcessingDatabaseUsers_ServiceDesc, srv)
}

func _ProcessingDatabaseUsers_GetUserEmbeddingByKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserEmbeddingByKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseUsersServer).GetUserEmbeddingByKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseUsers_GetUserEmbeddingByKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseUsersServer).GetUserEmbeddingByKey(ctx, req.(*GetUserEmbeddingByKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessingDatabaseUsers_IsRecordViewedByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsRecordViewedByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseUsersServer).IsRecordViewedByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseUsers_IsRecordViewedByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseUsersServer).IsRecordViewedByUser(ctx, req.(*IsRecordViewedByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessingDatabaseUsers_AddViewedRecordToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddViewedRecordToUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseUsersServer).AddViewedRecordToUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseUsers_AddViewedRecordToUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseUsersServer).AddViewedRecordToUser(ctx, req.(*AddViewedRecordToUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessingDatabaseUsers_DeleteUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessingDatabaseUsersServer).DeleteUserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessingDatabaseUsers_DeleteUserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessingDatabaseUsersServer).DeleteUserById(ctx, req.(*DeleteUserByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProcessingDatabaseUsers_ServiceDesc is the grpc.ServiceDesc for ProcessingDatabaseUsers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProcessingDatabaseUsers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Dressy.ProcessingDatabase.ProcessingDatabaseUsers",
	HandlerType: (*ProcessingDatabaseUsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserEmbeddingByKey",
			Handler:    _ProcessingDatabaseUsers_GetUserEmbeddingByKey_Handler,
		},
		{
			MethodName: "IsRecordViewedByUser",
			Handler:    _ProcessingDatabaseUsers_IsRecordViewedByUser_Handler,
		},
		{
			MethodName: "AddViewedRecordToUser",
			Handler:    _ProcessingDatabaseUsers_AddViewedRecordToUser_Handler,
		},
		{
			MethodName: "DeleteUserById",
			Handler:    _ProcessingDatabaseUsers_DeleteUserById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "processingdatabase.proto",
}
